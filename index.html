<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Preschool Fun!</title>
  <style>* { box-sizing: border-box; }
html, body { margin: 0; padding: 0; background: #f6efe7; color: #2a2a2a; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
#wrap { max-width: 980px; margin: 0 auto; padding: 12px; }
header { text-align: center; }
h1 { margin: 8px 0 4px; font-size: 2rem; }
.subtitle { margin: 0 0 8px; color: #5a5a5a; }
#game { width: 100%; border-radius: 12px; display: block; background: #cfe8ff; border: 2px solid #3a6ea5; }
footer { text-align: center; margin-top: 8px; color: #6a6a6a; }

#mobileControls { display: grid; place-items: center; gap: 6px; margin-top: 8px; }
#mobileControls .row { display: flex; gap: 10px; }
#mobileControls button { font-size: 20px; padding: 10px 14px; border-radius: 10px; border: 2px solid #3a6ea5; background: white; }
#mobileControls button:active { transform: translateY(1px); }

@media (min-width: 820px) {
  #mobileControls { display: none; }
}
</style>
</head>
<body>
  <div id="wrap">
    <header>
      <h1>Preschool Fun!</h1>
      <p class="subtitle">Use <kbd>WASD</kbd>/<kbd>Arrows</kbd> to move, <kbd>E</kbd> to interact, <kbd>P</kbd> to pause.</p>
    </header>
    <canvas id="game" width="960" height="540" aria-label="Game canvas" role="img"></canvas>
    <div id="mobileControls" aria-hidden="false">
      <button id="btnUp">â–²</button>
      <div class="row">
        <button id="btnLeft">â—€</button>
        <button id="btnInteract">E</button>
        <button id="btnRight">â–¶</button>
      </div>
      <button id="btnDown">â–¼</button>
    </div>
    <footer>
      <small>Â© 2025 â€” A tiny, wholesome web game.</small>
    </footer>
  </div>
  <script>(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Globals
  const W = canvas.width, H = canvas.height;
  const keys = new Set();
  let gameState = 'overworld'; // 'overworld' | 'art' | 'blocks' | 'music' | 'paused' | 'win'
  let completed = { art:false, blocks:false, music:false };
  let funMeter = 0; // 0..3

  // Helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random()*(b-a);

  // Input
  window.addEventListener('keydown', (e) => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key.toLowerCase() === 'p') {
      if (gameState === 'paused') gameState = prevState || 'overworld'; else { prevState = gameState; gameState = 'paused'; }
    }
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  // Mobile controls
  const bindHold = (id, key) => {
    const btn = document.getElementById(id);
    if (!btn) return;
    let down = false;
    const on = () => { down = true; keys.add(key); };
    const off = () => { down = false; keys.delete(key); };
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); on(); }, {passive:false});
    btn.addEventListener('touchend', (e) => { e.preventDefault(); off(); }, {passive:false});
    btn.addEventListener('mousedown', (e)=> { e.preventDefault(); on(); });
    btn.addEventListener('mouseup', (e)=> { e.preventDefault(); off(); });
    btn.addEventListener('mouseleave', off);
  };
  bindHold('btnUp','arrowup');
  bindHold('btnDown','arrowdown');
  bindHold('btnLeft','arrowleft');
  bindHold('btnRight','arrowright');
  const interactBtn = document.getElementById('btnInteract');
  if (interactBtn) {
    interactBtn.addEventListener('click', () => {
      // Trigger an interact press
      keys.add('e');
      setTimeout(()=>keys.delete('e'), 80);
    });
  }

  // World
  const world = {
    w: 2000, h: 1200,
    colliders: [
      // Fence boundaries (simple rectangle margins)
      {x:-40,y:-40,w:2080,h:40}, {x:-40,y:1200,w:2080,h:40},
      {x:-40,y:0,w:40,h:1200}, {x:2000,y:0,w:40,h:1200},
      // Buildings (simple obstacles)
      {x:1400,y:180,w:420,h:360},
      {x:180,y:180,w:420,h:360},
    ]
  };

  // Player (little red-headed boy)
  const player = {
    x: W/2, y: H/2, w: 36, h: 48, speed: 2.7, vx:0, vy:0, facing:'down'
  };

  // Camera
  let cam = { x:0, y:0 };

  // Interact stations
  const stations = [
    { id:'art', x:330, y:320, w:160, h:120, label:'Art Table ðŸŽ¨ (E)', color:'#ffdfa6'},
    { id:'blocks', x:980, y:820, w:180, h:120, label:'Blocks Corner ðŸ§± (E)', color:'#ffd6e7'},
    { id:'music', x:1650, y:320, w:160, h:120, label:'Music Mat ðŸŽµ (E)', color:'#d2ffd2'}
  ];

  function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  function moveAndCollide(p, dt){
    p.x += p.vx * dt; p.y += p.vy * dt;
    const r = {x:p.x - p.w/2, y:p.y - p.h/2, w:p.w, h:p.h};
    for(const c of world.colliders){
      if(rectsOverlap(r,c)){
        // resolve minimally
        const dx1 = (c.x + c.w) - r.x;   // c right to r left
        const dx2 = (r.x + r.w) - c.x;   // r right to c left
        const dy1 = (c.y + c.h) - r.y;   // c bottom to r top
        const dy2 = (r.y + r.h) - c.y;   // r bottom to c top
        const px = Math.min(dx1, dx2);
        const py = Math.min(dy1, dy2);
        if (px < py){
          // horizontal push
          if (dx1 < dx2) r.x = c.x + c.w; else r.x = c.x - r.w;
          p.x = r.x + p.w/2;
          p.vx = 0;
        } else {
          if (dy1 < dy2) r.y = c.y + c.h; else r.y = c.y - r.h;
          p.y = r.y + p.h/2;
          p.vy = 0;
        }
      }
    }
  }

  // Mini-game state
  const artGame = {
    targetSeq: [], seqIndex: 0, done:false, colors:['red','blue','yellow','green'],
    start(){
      // generate a random sequence of 4
      this.targetSeq = Array.from({length:4}, _=> this.colors[Math.floor(Math.random()*this.colors.length)]);
      this.seqIndex = 0; this.done = false;
    },
    clickColor(c){
      if (this.done) return;
      if (this.targetSeq[this.seqIndex] === c){
        this.seqIndex++;
        if (this.seqIndex >= this.targetSeq.length) { this.done = true; }
      } else {
        // reset progress feedback
        this.seqIndex = 0;
      }
    }
  };

  const blocksGame = {
    playerX: 160, speed: 4, blocks: [], caught:0, miss:0, done:false, t:0,
    start(){
      this.playerX = 160; this.blocks = []; this.caught = 0; this.miss = 0; this.done = false; this.t=0;
    },
    step(dt){
      this.t += dt;
      // Spawn blocks
      if (Math.random() < 0.02 + this.t*0.00002){
        this.blocks.push({x: rand(40, 320), y: -10, vy: rand(1.2,2.6)});
      }
      // Move blocks
      for(const b of this.blocks){ b.y += b.vy*dt*1.5; }
      // Catch logic
      const basketY = 280;
      this.blocks = this.blocks.filter(b => {
        if (b.y > basketY-8 && b.y < basketY+8 && Math.abs(b.x - this.playerX) < 26){
          this.caught++; return false;
        }
        if (b.y > 330){ this.miss++; return false; }
        return true;
      });
      if (this.caught >= 10) this.done = true;
      if (this.miss > 8) this.done = true; // end regardless
    }
  };

  const musicGame = {
    seq: [], input: [], playing:false, index:0, done:false, tones:[261.63,329.63,392.00,523.25],
    start(){
      this.seq = Array.from({length:5}, _=> Math.floor(Math.random()*4));
      this.input = []; this.index = 0; this.done = false;
      this.playing = true; this.playIndex = 0; this.lastPlay = 0;
      initAudio();
    },
    press(i){
      if (this.playing || this.done) return;
      this.input.push(i);
      beep(i, 0.15);
      if (this.seq[this.input.length-1] !== i){
        // wrong -> reset input
        this.input = [];
        return;
      }
      if (this.input.length === this.seq.length){
        this.done = true;
      }
    },
    step(time){
      if (!this.playing) return;
      const now = performance.now();
      if (now - this.lastPlay > 500){
        if (this.playIndex < this.seq.length){
          const i = this.seq[this.playIndex];
          beep(i, 0.2);
          this.lastPlay = now;
          this.playIndex++;
        } else {
          this.playing = false;
        }
      }
    }
  };

  // Simple WebAudio beeps
  let audioCtx = null;
  function initAudio(){
    if (!audioCtx) {
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      catch(e){ /* ignore */ }
    }
  }
  function beep(i, dur=0.2){
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.frequency.value = musicGame.tones[i];
    o.type = 'sine';
    g.gain.value = 0.0001;
    o.connect(g); g.connect(audioCtx.destination);
    const t = audioCtx.currentTime;
    g.gain.exponentialRampToValueAtTime(0.2, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    o.start(t); o.stop(t+dur+0.02);
  }

  // Draw helpers
  function drawRoundedRect(x,y,w,h,r, fill, stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if (fill){ ctx.fillStyle = fill; ctx.fill(); }
    if (stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke(); }
  }

  function drawWorld(){
    // Sky gradient
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#cfe8ff'); sky.addColorStop(1,'#e9ffd7');
    ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

    // Camera
    cam.x = clamp(player.x - W/2, 0, world.w - W);
    cam.y = clamp(player.y - H/2, 0, world.h - H);

    ctx.save();
    ctx.translate(-cam.x, -cam.y);

    // Grass
    ctx.fillStyle = '#b7e4a6';
    ctx.fillRect(0,0,world.w, world.h);

    // Paths
    ctx.fillStyle = '#ead9b6';
    ctx.fillRect(0,520,world.w, 160);

    // Buildings (classrooms)
    drawRoundedRect(180,180,420,360,16,'#ffe9c9','#a87838');
    drawRoundedRect(1400,180,420,360,16,'#ffe9c9','#a87838');
    // Doors
    drawRoundedRect(360,480,60,60,8,'#8ab3ff','#3a6ea5');
    drawRoundedRect(1580,480,60,60,8,'#8ab3ff','#3a6ea5');

    // Stations
    for(const s of stations){
      drawRoundedRect(s.x, s.y, s.w, s.h, 14, s.color, '#3a6ea5');
      ctx.fillStyle = '#2a2a2a';
      ctx.font = '16px sans-serif';
      ctx.fillText(s.label, s.x + 8, s.y + s.h + 18);
    }

    // NPC kids (bouncing blobs)
    for (let i=0;i<6;i++){
      const bx = 200 + (i*280)% (world.w-300);
      const by = 780 + 60*Math.sin((Date.now()/600)+(i*0.9));
      ctx.fillStyle = i%2? '#ffd3dd' : '#d0e7ff';
      drawRoundedRect(bx, by, 28, 28, 8, ctx.fillStyle, '#6a6a6a');
    }

    // Player
    drawPlayer();

    // UI markers for completed
    stations.forEach(s => {
      if (completed[s.id]){
        ctx.fillStyle = '#2a9d8f';
        ctx.font = '18px sans-serif';
        ctx.fillText('âœ”', s.x + s.w - 18, s.y + 24);
      }
    });

    ctx.restore();

    // HUD
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    drawRoundedRect(12,12, 200, 70, 10, 'rgba(255,255,255,0.9)', '#3a6ea5');
    ctx.fillStyle = '#2a2a2a';
    ctx.font = '18px sans-serif';
    ctx.fillText('Fun Meter:', 24, 38);
    // meter
    for (let i=0;i<3;i++){
      ctx.strokeStyle = '#3a6ea5'; ctx.lineWidth = 2;
      ctx.strokeRect(24 + i*58, 48, 48, 12);
      if (i < funMeter){
        ctx.fillStyle = ['#ffd166','#ef476f','#06d6a0'][i];
        ctx.fillRect(24 + i*58 + 1.5, 48 + 1.5, 48 - 3, 12 - 3);
      }
    }
  }

  function drawPlayer(){
    const px = player.x - cam.x, py = player.y - cam.y;
    // Body
    drawRoundedRect(px-18, py-12, 36, 36, 8, '#87c1ff', '#355e8c'); // shirt
    drawRoundedRect(px-14, py+20, 28, 18, 6, '#31445a', '#2a2a2a'); // shorts
    drawRoundedRect(px-12, py+36, 10, 8, 3, '#444', '#2a2a2a'); // left shoe
    drawRoundedRect(px+2, py+36, 10, 8, 3, '#444', '#2a2a2a'); // right shoe
    // Head
    drawRoundedRect(px-14, py-34, 28, 24, 8, '#ffdbb0', '#2a2a2a');
    // Hair (red)
    ctx.fillStyle = '#d4533f';
    ctx.beginPath();
    ctx.ellipse(px, py-34, 16, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(px-10, py-34, 8, Math.PI, 0);
    ctx.fill();
    // Eyes
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(px-6, py-26, 3, 3);
    ctx.fillRect(px+3, py-26, 3, 3);
    // Smile
    ctx.beginPath();
    ctx.arc(px, py-18, 6, 0, Math.PI);
    ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 2; ctx.stroke();
  }

  function promptText(lines){
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    drawRoundedRect(W/2-260, H-150, 520, 120, 12, 'rgba(255,255,255,0.95)', '#3a6ea5');
    ctx.fillStyle = '#2a2a2a';
    ctx.font = '18px sans-serif';
    lines.forEach((t,i)=> ctx.fillText(t, W/2 - 240, H-115 + i*24));
  }

  // Interaction
  let prevState = null;
  function checkInteraction(){
    const pr = {x: player.x - player.w/2, y: player.y - player.h/2, w: player.w, h: player.h};
    for (const s of stations){
      const area = {x:s.x, y:s.y, w:s.w, h:s.h};
      if (rectsOverlap(pr, area)){
        // show prompt
        promptText([s.label.replace(' (E)',''), 'Press E to play!']);
        if (keys.has('e')){
          if (s.id==='art'){ artGame.start(); gameState = 'art'; }
          if (s.id==='blocks'){ blocksGame.start(); gameState = 'blocks'; }
          if (s.id==='music'){ musicGame.start(); gameState = 'music'; }
          keys.delete('e');
        }
      }
    }
  }

  // Game loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(33, now-last); last = now;
    ctx.clearRect(0,0,W,H);

    if (gameState === 'overworld'){
      // movement
      const up = keys.has('w') || keys.has('arrowup');
      const down = keys.has('s') || keys.has('arrowdown');
      const left = keys.has('a') || keys.has('arrowleft');
      const right = keys.has('d') || keys.has('arrowright');
      player.vx = (right?1:0) - (left?1:0);
      player.vy = (down?1:0) - (up?1:0);
      const mag = Math.hypot(player.vx, player.vy) || 1;
      player.vx = player.vx / mag * player.speed;
      player.vy = player.vy / mag * player.speed;
      moveAndCollide(player, dt);

      drawWorld();
      checkInteraction();
      if (funMeter >= 3) { gameState = 'win'; }
    }
    else if (gameState === 'paused'){
      drawWorld();
      promptText(['Paused','Press P to resume']);
    }
    else if (gameState === 'art'){
      drawMiniArt();
    }
    else if (gameState === 'blocks'){
      drawMiniBlocks(dt);
    }
    else if (gameState === 'music'){
      musicGame.step(now);
      drawMiniMusic();
    }
    else if (gameState === 'win'){
      drawWorld();
      promptText(['You had an awesome day at preschool! ðŸŽ‰', 'Thanks for playing!']);
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ---- Mini-games ----

  function drawBackButton(){
    drawRoundedRect(W-150, 16, 130, 40, 10, '#ffffff', '#3a6ea5');
    ctx.fillStyle = '#2a2a2a'; ctx.font = '18px sans-serif';
    ctx.fillText('â† Back (E)', W-140, 42);
    if (keys.has('e')){
      keys.delete('e');
      gameState = 'overworld';
    }
  }

  function awardIfFirst(id){
    if (!completed[id]){
      completed[id] = true;
      funMeter = Object.values(completed).filter(Boolean).length;
    }
  }

  // ART: color-sequence clicker
  function drawMiniArt(){
    // bg
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0,'#fff6e5'); grd.addColorStop(1,'#ffead1');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

    ctx.fillStyle = '#2a2a2a'; ctx.font = '22px sans-serif';
    ctx.fillText('Art Time! Repeat the color sequence to color the smiley.', 40, 50);

    // target sequence
    ctx.font = '18px sans-serif';
    ctx.fillText('Sequence:', 40, 80);
    artGame.targetSeq.forEach((c,i)=>{
      ctx.fillStyle = c; drawRoundedRect(120+i*38, 64, 30, 20, 6, c, '#333');
    });

    // progress
    ctx.fillStyle = '#2a2a2a';
    ctx.fillText('Your progress:', 40, 120);
    drawRoundedRect(180, 106, 260, 18, 9, '#ffffff', '#333');
    if (artGame.seqIndex>0){
      ctx.fillStyle = '#8fd694';
      ctx.fillRect(182,108, (256*(artGame.seqIndex/artGame.targetSeq.length)), 14);
    }

    // smiley
    ctx.beginPath(); ctx.arc(W-260, H/2, 90, 0, Math.PI*2);
    ctx.fillStyle = '#fff47a'; ctx.fill(); ctx.strokeStyle = '#a88600'; ctx.lineWidth = 4; ctx.stroke();
    // eyes & mouth
    ctx.fillStyle = '#2a2a2a';
    ctx.beginPath(); ctx.arc(W-300, H/2-20, 8, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(W-220, H/2-20, 8, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(W-260, H/2+10, 40, 0, Math.PI); ctx.lineWidth=5; ctx.stroke();

    // crayons
    const crayons = artGame.colors.map((c,i)=> ({c, x: 60 + i*120, y: H-140, w: 80, h: 40}));
    crayons.forEach(cr => {
      drawRoundedRect(cr.x, cr.y, cr.w, cr.h, 10, cr.c, '#2a2a2a');
      ctx.fillStyle = '#000';
      ctx.font = '14px sans-serif';
      ctx.fillText(cr.c.toUpperCase(), cr.x + 10, cr.y + 26);
    });

    // mouse handling
    if (!drawMiniArt.bound){
      canvas.addEventListener('click', (e) => {
        if (gameState !== 'art') return;
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvas.width/rect.width);
        const my = (e.clientY - rect.top) * (canvas.height/rect.height);
        crayons.forEach(cr => {
          if (mx>=cr.x && mx<=cr.x+cr.w && my>=cr.y && my<=cr.y+cr.h){
            artGame.clickColor(cr.c);
          }
        });
      });
      drawMiniArt.bound = true;
    }

    if (artGame.done){
      ctx.fillStyle = '#2a9d8f'; ctx.font = '26px sans-serif';
      ctx.fillText('Great coloring! âœ”', 40, 160);
      awardIfFirst('art');
    }
    drawBackButton();
  }

  // BLOCKS: catch falling blocks with a basket
  function drawMiniBlocks(dt){
    const bg = ctx.createLinearGradient(0,0,0,H);
    bg.addColorStop(0,'#ffe7f4'); bg.addColorStop(1,'#ffd6e7');
    ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);

    ctx.fillStyle = '#2a2a2a'; ctx.font = '22px sans-serif';
    ctx.fillText('Blocks! Move the basket to catch 10 blocks.', 40, 50);

    // Basket controls
    if (keys.has('arrowleft')||keys.has('a')) blocksGame.playerX -= blocksGame.speed;
    if (keys.has('arrowright')||keys.has('d')) blocksGame.playerX += blocksGame.speed;
    blocksGame.playerX = clamp(blocksGame.playerX, 40, 320);

    // step
    blocksGame.step(dt);

    // playfield box
    drawRoundedRect(40, 90, 320, 260, 12, '#ffffff', '#3a6ea5');

    // blocks
    for (const b of blocksGame.blocks){
      drawRoundedRect(40 + (b.x-40), 90 + (b.y), 16, 16, 4, '#ef476f', '#8a1e2e');
    }

    // basket
    drawRoundedRect(40 + blocksGame.playerX-24, 90+280-10, 48, 12, 6, '#06d6a0', '#0d775f');

    // score
    ctx.fillStyle = '#2a2a2a'; ctx.font = '18px sans-serif';
    ctx.fillText(`Caught: ${blocksGame.caught}   Missed: ${blocksGame.miss}`, 40, 380);

    if (blocksGame.done){
      if (blocksGame.caught >= 10){
        ctx.fillStyle = '#2a9d8f'; ctx.font = '26px sans-serif';
        ctx.fillText('Awesome catching! âœ”', 40, 410);
        awardIfFirst('blocks');
      } else {
        ctx.fillStyle = '#e76f51'; ctx.font = '20px sans-serif';
        ctx.fillText('Try again â€” press E to exit and re-enter.', 40, 410);
      }
    }
    drawBackButton();
  }

  // MUSIC: Simon Says of 4 pads
  function drawMiniMusic(){
    const bg = ctx.createLinearGradient(0,0,0,H);
    bg.addColorStop(0,'#e8fff0'); bg.addColorStop(1,'#d2ffd2');
    ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);

    ctx.fillStyle = '#2a2a2a'; ctx.font = '22px sans-serif';
    ctx.fillText('Music Time! Watch the pattern, then repeat it.', 40, 50);

    const pads = [
      {x: 140, y: 140, w: 120, h: 120, label:'Do', color:'#8ecae6'},
      {x: 300, y: 140, w: 120, h: 120, label:'Re', color:'#ffb703'},
      {x: 140, y: 300, w: 120, h: 120, label:'Mi', color:'#fb8500'},
      {x: 300, y: 300, w: 120, h: 120, label:'So', color:'#90be6d'}
    ];

    pads.forEach((p,i)=>{
      const highlight = (musicGame.playing && musicGame.playIndex-1===i) ? 1 : 0;
      drawRoundedRect(p.x, p.y, p.w, p.h, 18, p.color, '#2a2a2a');
      if (highlight){
        ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 6;
        ctx.strokeRect(p.x+3, p.y+3, p.w-6, p.h-6);
      }
      ctx.fillStyle = '#2a2a2a'; ctx.font = '20px sans-serif';
      ctx.fillText(p.label, p.x + 44, p.y + 66);
    });

    // Mouse input
    if (!drawMiniMusic.bound){
      canvas.addEventListener('click', (e) => {
        if (gameState !== 'music') return;
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvas.width/rect.width);
        const my = (e.clientY - rect.top) * (canvas.height/rect.height);
        pads.forEach((p,i)=>{
          if (mx>=p.x && mx<=p.x+p.w && my>=p.y && my<=p.y+p.h){
            musicGame.press(i);
          }
        });
      });
      drawMiniMusic.bound = true;
    }

    // status
    ctx.fillStyle = '#2a2a2a'; ctx.font = '18px sans-serif';
    if (musicGame.playing) ctx.fillText('Playing patternâ€¦', 40, 90);
    else ctx.fillText(`Your turn: ${musicGame.input.length}/${musicGame.seq.length}`, 40, 90);

    if (musicGame.done){
      ctx.fillStyle = '#2a9d8f'; ctx.font = '26px sans-serif';
      ctx.fillText('Lovely music! âœ”', 40, 460);
      awardIfFirst('music');
    }

    drawBackButton();
  }

})();</script>
</body>
</html>
